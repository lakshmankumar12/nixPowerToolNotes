constructs
-----------

if [ condition  ] ; then
  statement
elif [ condition ] ; then
  statement
else
  statement
fi

substring
----------

${i:index}     .. substring of i starting at index(0-based)
${i:index:len} .. substring of i starting at index(0-based) for length len

is substring in string
----------------------
if [[ $haystack == *"$needle"* ]]
then
  echo "It's there!";
fi

Filenames and extractions
------------------------

filename=$(basename "$fullpathfile")
dirname=$(dirname "$fullpathfile")
extension="${filename##*.}"
filename="${filename%.*}"


Arrays
------

Initialize an array literal using paranthsesis
array=(one two three)

index is a number. Gaps are okay when initializing. those members dont exist

#remember the flow-brace after dollar and before arr-name.

${Array[index]}

eg:
a=("hello" "world")
echo ${a[0]}   # prints hello
echo ${#a[@]}  # prints 2. Note where # appears
for i in ${a[@]} ; do echo happy $i ; done #  iterates.

reference: http://www.tldp.org/LDP/abs/html/arrays.html#ARRAYSTROPS

${a[@]/#/XY}  #adds a XY to the beginning of all members
${a[@]/%/XY}  #adds a XY to the end of all members

gobble a command's line into a array:

IFS=$'\r\n' GLOBIGNORE='*' XYZ=($(command))

In zsh
~~~~~~

sentence="Space separated collection of words"
eval "arrayOfWords=($sentence)"
for i in $arrayOfWords ; do echo "word in this iteration is $i"; done


Iterating over each line of a  file
-----------------------------------

while read i ; do echo "one line: $i" ; done < file

Note: for i in $(cat line) .. will interate over each word of the file, not line!
Note: cat file | while     .. wont cut it as while will work in a bash of its own and variables modifed inside
                                         while wont be seen by this bash.

List all key-bindings in zsh
-----------------------------

bindkey -L

echo with colors
----------------

https://en.wikipedia.org/wiki/Tput
https://en.wikipedia.org/wiki/ANSI_escape_code#Colors

tput setaf

reset:
tput sgr0

Direct colors:
~~~~~~~~~~~~~

echo -ne 'Any of these in single quote'

reset:
'\033[0;0m'

set:
'\033[1;35m'

\033[ x;y;z m
x=1 or leave.. bold text ( This doesn't work very well in solarized)
  4 or leave.. underline
y=30-37  .. for text color        90..97 increased intensity
z=40-47  .. for background color  100..107 increased intensity

    0  1  ..     2 3      ....    4 5       ..    6 7
Black Red .. Green Yellow .... Blue Magenta .. Cyan White

Getting yes/no or other inputs from user
----------------------------------------

echo "Do you wish to install this program?"
select yn in "Yes" "No"; do
    case $yn in
        Yes ) echo "Yay"; break;;
        No ) echo "Nay"; break;;
    esac
done

or

while true; do
    read -p "Do you wish to install this program?" yn
    case $yn in
        [Yy]* ) echo "Yay" ; break;;
        [Nn]* ) echo "Nay" ; break;;
        * ) echo "Please answer yes or no.";;
    esac
done

Find all unique files in 2 folders
-----------------------------------

#this WONT GIVE u if a file is present twice is DIR1 itself but absent in DIR2!
export DIR1=whatever
export DIR2=whatever2
find $DIR1 $DIR2 -type f -exec sha1sum '{}' \+ | sort | uniq -c --check-chars 40 | egrep '^ *1 ' | cut -c 51-

Running sth at exit no-matter-what
----------------------------------

function my_function {
  rm whatever;
}

trap my_function INT TERM EXIT HUP

Do sth in a lock
-----------------

lockfile=/var/tmp/mylock

if ( set -o noclobber; echo "$$" > "$lockfile") 2> /dev/null; then

        trap 'rm -f "$lockfile"; exit $?' INT TERM EXIT

        # do stuff here

        # clean up after yourself, and release your trap
        rm -f "$lockfile"
        trap - INT TERM EXIT
else
        echo "Lock Exists: $lockfile owned by $(cat $lockfile)"
fi

Argc/Argv Parsing
-----------------

good
* long-options and short-options

bad
* can't support args after options.. Grr!
* no unix sytle combining of options

----
#Usage: ./myscript.sh -e conf -s /etc -l /usr/lib /etc/hosts 
# note: if this is set to > 0 the /etc/hosts part is not recognized ( may be a bug )
while [[ $# > 1 ]]
do
key="$1"

case $key in
    -e|--extension)
    EXTENSION="$2"
    shift # past argument
    ;;
    -s|--searchpath)
    SEARCHPATH="$2"
    shift # past argument
    ;;
    -l|--lib)
    LIBPATH="$2"
    shift # past argument
    ;;
    --default)
    DEFAULT=YES
    ;;
    *)
            # unknown option
    ;;
esac
shift # past argument or value
done
echo FILE EXTENSION  = "${EXTENSION}"
echo SEARCH PATH     = "${SEARCHPATH}"
echo LIBRARY PATH    = "${LIBPATH}"
echo "Number files in SEARCH PATH with EXTENSION:" $(ls -1 "${SEARCHPATH}"/*."${EXTENSION}" | wc -l)
if [[ -n $1 ]]; then
    echo "Last line of file specified as non-opt/last argument:"
    tail -1 $1
fi

----

or

good
* unix sytle combining of options
* can support args after options.. Grr!

bad
* no long-options support

----
OPTIND=1         # Reset in case getopts has been used previously in the shell.

# Initialize our own variables:
output_file=""
verbose=0

while getopts "h?vf:" opt; do
    case "$opt" in
    h|\?)
        show_help
        exit 0
        ;;
    v)  verbose=1
        ;;
    f)  output_file=$OPTARG
        ;;
    esac
done

shift $((OPTIND-1))

[ "$1" = "--" ] && shift
Leftovers=$@
----

Finding who set that env variable
---------------------------------

env - typically lists variables in the order in which it was set.

zsh -xl --> Super dump of all scripts that is run during a sesseion init.

bash:
PS4='+$BASH_SOURCE> ' BASH_XTRACEFD=7 bash -xl 7>&2

source: http://unix.stackexchange.com/a/154971


Argument referencing
--------------------

http://zsh.sourceforge.net/Doc/Release/Expansion.html

<Event Designator>:<Word Designator>:<Modifier>

Event Designator - chooses which command

!! last comand
!-n last nth command .. !-1 is same as !-2
!# current command so far


Word Designator - if blank, entire command.

0 - first word (command)
1 - first arg
n - nth arg
$ - last arg

Modifier

a - abs path name
h - like dirname
t - like basename




