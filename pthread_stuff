
Mutex
-----

pthread_mutex_init(&mutex,&attr);
pthread_mutex_destroy(&mutex);  /* undefined if mutex is locked at destroy ! */

pthread_once(&pthread_once_t,function_p);

pthread_mutex_lock(&mutex);
pthread_mutex_trylock(&mutex);
pthread_mutex_unlock(&mutex);

Cond-wait
----------

int pthread_cond_wait(pthread_cond_t *cptr, pthread_mutex_t *mptr );
int pthread_cond_timedwait(pthread_cond_t *cptr, pthread_mutex_t *mptr , const timespec *);
int pthread_cond_signal (pthread_cond_t *cptr);
int pthread_cond_broadcast (pthread_cond_t *cptr);    /* wakes up all threads waiting */

eg: cond_wait in prod/consumer problem

struct {
  pthread_mutex_t mutex;
  pthread_cond_t cond;
  int nready;                   /* number ready for consumer */
} nready = {
PTHREAD_MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER
};

producer:
~~~~~~~~~

pthread_mutex_lock(&nready.mutex);
if (nready.nready == 0) {
  pthread_cond_signal(&nready.cond);            /* Note -- Signalling does nothing about the mutex . You can signal outside the mutex too */
}
nready.nready++;
pthread_mutex_unlock(&nready.mutex);

Alternate:
+++++++++

auto int do_signal = 0;

pthread_mutex_lock(&nready.mutex);
if (nready.nready == 0) {
  do_signal = 1;
}
nready.nready++;
pthread_mutex_unlock(&nready.mutex);

if (do_signal) {
  pthread_cond_signal(&nready.cond);            /* Note -- You can signal outside the mutex too */
}

consumer:
~~~~~~~~

Pthread_mutex_lock(&nready.mutex);
while (nready.nready == 0)                            /* while(ready-var) helps in preventing spurious wake up calls
  Pthread_cond_wait(&nready.cond, &nready.mutex);     /* Note: wait releases the mutex. So always call wait within mutex. And wait will re-acquire mutex when it returns */
nready.nready--;
Pthread_mutex_unlock(&nready.mutex);

read-write-locks
----------------

pthread_rwlock_t
