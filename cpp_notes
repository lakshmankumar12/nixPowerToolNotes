
New:

* allocate memory  .. operator new (size_t)
* call constructor

Delete:

* call destructor
* operator delete(void*)

enum class Traffic_light { Red, green, yellow };
 * strict type-checking
 * we can define operators for this. -- Traffic_light& operator++(Traffic_light& t)

static_assert(A,S) prints S as a compiler error message if A is not true.

const int a=5; <-- a is a named-const
constexpr double max1 = 1.4∗square(dmv); // constexpr: meaning roughly ‘‘to be evaluated at compile time’’
                                         // In above example, the function square should also be a constexpr like below
constexpr double square(double x) { return x∗x; }   // a constexpr function can be called from anywhere. Just that the result wont be constexpr.
                                                    // This allows same function for both variables and constexpr

std::initializer_list<T> lst;
 Has the following attributes
   lst.size()

eg: std::initializer_list<double> lst{2.2,2.3,2.4};

unique_ptr<T>
  -> when it goes out of scope, it deletes the object underneath

std::move(x);
  -> get an rvalue for x. This helps in invoking a move-assignment
      z=x;            // copy-assignment
      z=std::move(x); // move assignment


=delete; can be used to suppress any operation, that the compiler does for free.

Signatures for common function
------------------------------

binary operators

const Object operator+(const Object &lhs, const Object &rhs);
   -- note the return is const-value, while args are const-references

assignment

Object& Object::operator=(const Object &rhs);
Object& Object::operator=(const DiffTypeObject &rhs);
   -- note non-const reference return and const reference arg.
   -- same for all assignments like +=,-=,*=,/=


Effective C++

Accustoming to C++

Item 1: parts of c++ -> c, oo-part, template-part and STL
Item 2: const, enum and inlines to #define
          -- static const inside class needn't have definition (integral types - as long as address is not taken)
          -- #define dont have scope
          -- inline functions have type-checking, and can accept expressions as arguments, which wil be evaluated once.
Item 3: use  const wherever possible
          -- const Rational operator*(const Rational &lhs, const Rational &rhs);
             -- const helps to avoid unnecessary assignment to a return value
          -- member functions can be overloaded with const
          -- bitwise constness, logical constness


Constructors, Destructors and Assignment Operators

Item 4: Objects shoudl be initialized before their use
          -- use initialization list
          -- order of initailzation is base-class, member definition order.
          -- avoid initialization order problem, by having data-members local to compilation unit and static
Item 5: Functions that are auto-generated by compiler
          -- Default constructor (But this wont be provided if some other constructor is explicity declared)
          -- copy constructor, assignment operator , destructor
          -- copy/assignment will be rejected if the class has any const member or a reference (references are kind of *const)
Item 6: Explicitly disalloc functions if u dont want
          -- Make copy constructor and assignment private if the class shouldn't copy.
          -- One can use a Uncopyable base class as show in the item.
            -- Note the private inheritance
Item 7: Polymorphic class should have virtual destructor
          -- Polymorphic classes should have virtual destructor
          -- non polymorphic classes shoudn't
Item 8: Destructors should not throw exceptions
          -- Destructor may already be called in a exception unwinding stack. So it may leaad to double-throw
          -- Swallow it in destructor
          -- If class clients need to be able to react to exceptions thrown during
             an operation, the class should provide a regular (i.e., non-destructor) function that performs the operation.
Item 9: Never call virtual functions from constructors or destructors
          -- In a constructor, constructor will only statically call the base-class function from within constructor scope!
             Even if u call out to another method and call another virtual function, it will disastrous, as the derived
             object hasn't been built yet.
Item 10: Follow assignment operator signature convention (see above for the signature)
Item 11: Handle self-assignment in assignment operator.
          -- Ensure order of operatorions is right. Dont delete the rhs's data before lhs is ready
Item 12: Initialize all parts of a class
          -- Ensure to initialize/copy/assign all members of the class
          -- Ensure to call the right copy/assingment operators of all base classes
          -- Dont implement one constructor/assignment operator with another. Have a 3rd function and calls this from all 
             constructors and assignment operators



             

     

