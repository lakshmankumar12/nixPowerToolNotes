
List all tracked files
----------------------

git ls-files
git ls-tree --full-tree -r HEAD   # too complex for the above?

List all untracked files
------------------------

git ls-files --others --exclude-standard

Get a particular revision
-------------------------

git show treeish:path/to/file

use HEAD to get the tip.

Git bring back a file discarding chagnes
---------------------------------------

git checkout -- path/to/file

restore to head discarding all changes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

git checkout -- .

getting rid of the top-commit
-----------------------------

git reset --hard HEAD~1

# you can get it back as long as its in the same repo with git reflog (git pack may erase it after some time..)

List all branches in server and clone
----------------------------

git branch -a

If you dont see remotes/origin branches here, then your refspec isn't good.

Check repo_root/.git/config and see if you have this:

[remote "origin"]
    url = WHATEVER
    fetch = +refs/heads/*:refs/remotes/origin/*

If you are missing the fetch line, add it.

checkout remote branch with tracking
-------------------------------------

git checkout --track -b <local branch> <remote>/<tracked branch>

# if -b <name> is to be same as remote's name, you can skip it
git checkout -t origin/haml

# if brach is already present locally
git branch -u origin/remote_branch_name local_branch_name
git branch --set-upstream-to=upstream/remote_branch_name

# to set the refspec right.
git config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"

TO see all changes to a file across all branch
----------------------------------------------

git log --all -- <path/to/file>

Various flavors of git-log
--------------------------

git log --author=abc         # show all commits of author
git log --grep=efg           # show all commits with comments having the string
git log -S=hij               # show all commits with changed lines having the string. Slower -> so narrow ur commit-list
git log --name-only          # display names of files changed with every commit

git log --pretty=fuller      # shows both dates

To get the tag done on a given date
-----------------------------------

git describe branch_name@{mar.04.2016}  # This uses reflog.. so u may see only available till date.

git log branch_name --until=aug.04.2016

git describe --tags $(git rev-list -n 1 --before=05.aug.2015 HEAD)  #sub head with branch if u are not in branch

To quickly get the sha-1 of any tag/branch-name/commit-representative!
----------------------------------------------------------------------

#especially if you are in a script
git rev-parse HEAD
git rev-parse tag_name

#to check if this is a git-repo
git rev-parse HEAD
if [ $? -eq 0 ] ; then
  echo "you are in a git repo"
else
  echo "you are NOT in a git repo"

Get upstream info
-----------------

git rev-parse --abbrev-ref @{u}


To get the commit from where you started working
------------------------------------------------

Normally, @{u} is enuf. However, if you did a git fetch, chances are @{u} has advanced.

git merge-base @{u} $(git symbolic-ref --short -q HEAD)


git diff args
--------------

git diff <lhs-commit> <rhs-commit> <file-path>

git diff HEAD -- <all-files>



Difftool with a different tool
------------------------------

git difftool -t meld 


***********

Vim-fugitive notes
=================

* fugitive works only on a file. So just open a file and then issue any fugitive command

:Gdiff             # diff the current file's changes from index
:Gdiff HEAD
:Gdiff any_treeish

:Gedit <commit>
:Glog -n 5         #log the current-file, until 5 commits
:Glog -n 5 --      #log from HEAD to HEAD~4

To get the current commit while watching Gedit - y, then ^g

Equivalents
-----------

cmd-line           fugitive            Comments
git anything       :Git anything       Execute any random git command

:Git add %         :Gwrite             Stage the current file to the index
:Git checkout %    :Gread              Revert current file to last checked in version
:Git rm %          :Gremove            Delete the current file and the corresponding Vim buffer
:Git mv %          :Gmove              Rename the current file and the corresponding Vim buffer

:Git commit        :Gcommit
:Git status        :Gst

***********

GIt-notes
--------
There are 3 object types

1. blob   - File-contents
2. tree   - dir-listing, that bundles blobs together
3. commit - that points to a tree, with a meta-data like comments, author and a pointer to the previous commit(s)!.

A branch is simply a pointer to a commit. HEAD is a pointer to the current branch!

Know type of a sha
------------------

git cat-file -t <sha>

Get new clone
-----------

git-ws --branch v160.main asr5k/master.git master

git submodule  
git submodule status | grep '^ '

rolldown:

git forest pull

Getting a tag
--------------

git-ws --tag  buildnumber_54290 asr5k/master master

creating a annotated tag
-----------------------

git tag -a <tagname> -m '<message>'

Get info of a annotaed tag
---------------------------

git tag -l 'prefix*'   # will give all tags that start with prefix
git tag -l '*substr*'  # will give all tags that have substr

git show <tag-name>    # will show info of tag + the commit as well. Can get the time of the tagging.

Push only one or a few commits when we have more local commits
--------------------------------------------------------------

git push <remotename> <commit SHA>:<remotebranchname>
git push <remotename> <commit SHA>:refs/heads/<new-remotebranchname-name>

Push a tag
-----------

git push origin <tag_name>

delete a tag from remote
------------------------

git push --delete origin tagname

#https://nathanhoad.net/how-to-delete-a-remote-git-tag
git push origin :refs/tag/tagname

delete commits from remote
---------------------------

#This will force remote to sync up with us.
#Assuming all refspecs are set i.e tracking branch is set
git push remote_name -f

# This will do it wherever u are w/o any tracking branch set.
git push remote_name +COMMIT_ID:branch


getting latest /top commit
-----------------------
git log -n 1
git log -n 1 --pretty=format:"%H"

geting parent commit of a commit
---------------------------------

git show --quiet --pretty=format:"%P" <commit>

commit~1  .. First Parent of commit
commit~2  .. Grand(second) Parent of commit

commit^1  .. First left parent of commit
commit^2  .. second left parent of commit (meaningful for merge commits)


which branches contain a commit
------------------------------

git branch -a --contains <commit>

which commit has a certain version of file
------------------------------------------

which_commit_has_this_blob.pl <blob-sha>

getting rid of a submodule
---------------------------

git submodule deinit packages/<..>


doing a csettool:
-----------------

commit=<whatever>
parent=$(git show --quiet --pretty=format:"%P" $commit)
git meld $parent $commit

Getting older revisions of files:
---------------------------------

Get the revision of a submodule of a particular revision of a super module

git ls-tree buildnumber_50269 packages/common
cd packages/common
git show <commit>:<file>

getting the commit id of a submodule for a given commit of super-module
------------------------------------------------------------------------

git ls-tree -r <master-commit> | grep 'packages/<package>'

git ls-tree -r HEAD | grep 'packages/<package>'

is a commit in a build-number
-----------------------------

git merge-base --is-ancestor <commit> buildnumber_<build>

During merging / merge
--------------

# list conflict files
git diff --name-only --diff-filter=U

# to keep local or remote files
git checkout --theirs /path/to/file
git checkout --ours /path/to/file

git ls-files -u
  1: common
  2: ours
  3: theirs

Better merge strategy
--------------------

git merge|rebase|cherry-pick  --strategy=recursive --strategy-option=patience

To amend dates for a bulk of commits
-------------------------------------

git rebase -i
#choose edit in the EDITOR
#and do this when you are prompted in each stage

git commit --amend --date="Wed Feb 16 14:00 2011 +0100"
git rebase --continue

Bisect
-------

git bisect start <bad> <good> --
git bisect run /script

git bisect start HEAD TiMOS-MG_0_0_I1630 --

worktree
---------

git worktree add <path> [<branch>]    # add path and checkout branch into it.

Eg:
----
$ git worktree add -b emergency-fix ../temp master
$ pushd ../temp
# ... hack hack hack ...
$ git commit -a -m ´emergency fix for boss´
$ popd
$ rm -rf ../temp
$ git worktree prune
----

git worktree list

goto root of repo
-----------------

#gives absolute path
git rev-parse --show-toplevel

#gives relative-path (or) empty if already in root
git rev-parse --show-cdup

#useful bash-alias for bashrc
alias gitroot='cd ./$(git rev-parse --show-cdup)'

panos-flow
~~~~~~~~~~

#to create study only branches off some tag
git worktree add -b 60R4_study   ../../60R4_study/panos TiMOS-MG_6_0_R4

#to create a regular working branch to push
git worktree add -b mg80f ../../mg80f/panos remotes/origin/TiMOS-MG_8_0_future




Old commands equivalent
-----------------------

bk -r diffs -u -p            git diff -u -p
bk sfiles -Ug                git ls-tree -r HEAD --name-only 
bk sfiles -cg                git ls-files --modified
bk sfiles -gp                git ls-files --cached
bk unedit <file>             git checkout -- <file>                       .. careful!
bk unedit $(bk sfiles -cg)   git checkout -- $(git ls-files --modified)   .. careful!
bk delta -Y $(..)            git add $(git ls-files --modified)
bk sfiles -x                 ??
bk changes                   git log 
bk changes -L                git log  origin/v160.main..HEAD
bk changes -R                git fetch ; git log ..origin/v160.main
                             git fetch ; git log ..$(git branch -vv | grep '^*' | awk -F\' '{print $2}')
bk cset -r                   git diff-tree --no-commit-id --name-only -r <commit-id>
model                        git submodule status | grep -v '^-'
                             git submodule status | grep -v '^-' | awk ' {print $2 }' | awk -F\/ '{print $2}'| grep -v buildtools
bk undo -r<>                 git reset --hard HEAD~1
bk cset -x                   ??
bk export -tpatch            git show --pretty=format: <commit> | tail -n +2 
bk changes -u<user>          git log --author=<user>
bk changes -/text/           git log --grep=<text>


***********

Create a new branch

git checkout -b branch_name

Switch to a branch

git checkout test

Create a new branch that tracks a branch

git branch -t name remotes/origin/name
git checkout name


*****

Info model
-----------

files,
a working tree,
an index,
a local repository,
a remote repository,
remotes (pointers to remote repositories),
commits,
treeishes (pointers to commits),
branches,
a stash

refs
tags
the reflog
fast-forward commits
detached head state
remote branches
tracking
namespaces



*******

cvs commands

#set a CVSROOT
cvs -d '<...>' co repoName

#get root
cat CVS/Root

#update a repo
cvs update -Pqd

