
List all tracked files
----------------------

git ls-files
git ls-tree --full-tree -r HEAD   # too complex for the above?

List all untracked files
------------------------

git ls-files --others --exclude-standard

Get a particular revision
-------------------------

git show treeish:path/to/file

use HEAD to get the tip.

Git bring back a file discarding chagnes
---------------------------------------

git checkout -- path/to/file

restore to head discarding all changes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

git checkout -- .

getting rid of the top-commit
-----------------------------

git reset --hard HEAD~1

# you can get it back as long as its in the same repo with git reflog (git pack may erase it after some time..)

List all branches in server and clone
----------------------------

git branch -a

If you dont see remotes/origin branches here, then your refspec isn't good.

Check repo_root/.git/config and see if you have this:

[remote "origin"]
    url = WHATEVER
    fetch = +refs/heads/*:refs/remotes/origin/*

If you are missing the fetch line, add it.

checkout remote branch with tracking
-------------------------------------

git checkout --track -b <local branch> <remote>/<tracked branch>

# if -b <name> is to be same as remote's name, you can skip it
git checkout -t origin/haml

# if brach is already present locally / existing track
git branch -u origin/remote_branch_name local_branch_name
git branch --set-upstream-to=upstream/remote_branch_name

# to set the refspec right.
git config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"

# if remote deleted branches, then use this to clear if off ur local repo too
git remote prune origin

TO see all changes to a file across all branch
----------------------------------------------

git log --all -- <path/to/file>

Various flavors of git-log
--------------------------

git log --author=abc         # show all commits of author
git log --grep=efg           # show all commits with comments having the string
git log -S=hij               # show all commits with changed lines having the string. Slower -> so narrow ur commit-list
git log --name-only          # display names of files changed with every commit

git log --pretty=fuller      # shows both dates


Various pretty
--------------

git log --pretty=oneline     # <sha1> <title line>
                 short       # 2LH + message, commit/author
                 medium
                 full
                 fuller
                 format:".."

                 %H/%h = commit hash/abbr-hash
                 %T/%t = tree   hash/abbr-hash
                 %P/%p = parent hashes
                 %an   = author name
                 %ad/%aD/%ar/%i/%I = author-date  (data=/2822/relative/unixTim/ISO8601/strict)
                 %cd/%cD/%cr/%i/%I = author-date  (data=/2822/relative/unixTim/ISO8601/strict)

--name-only   : Adds filenames
--name-status : Adds a M to filename.
--stat        : count of lines changed.

To get the tag done on a given date
-----------------------------------

git describe branch_name@{mar.04.2016}  # This uses reflog.. so u may see only available till date.

git log branch_name --until=aug.04.2016

git describe --tags $(git rev-list -n 1 --before=05.aug.2015 HEAD)  #sub head with branch if u are not in branch

mgtags 80S | tail -n 100 | while read i ; do npgit log -n 1 --decorate --pretty=format:"$i %cD" $i ; echo ; ; done

#print every 50th tag.
mgtags 80S | sed -n '1~50p' | while read i ; do npgit log -n 1 --decorate --pretty=format:"$i %cD" $i ; echo ; ; done

To quickly get the sha-1 of any tag/branch-name/commit-representative!
----------------------------------------------------------------------

#especially if you are in a script
git rev-parse HEAD
git rev-parse tag_name

#to check if this is a git-repo
git rev-parse HEAD
if [ $? -eq 0 ] ; then
  echo "you are in a git repo"
else
  echo "you are NOT in a git repo"

Get upstream info
-----------------

git rev-parse --abbrev-ref @{u}


To get the commit from where you started working
------------------------------------------------

Normally, @{u} is enuf. However, if you did a git fetch, chances are @{u} has advanced.

git merge-base @{u} $(git symbolic-ref --short -q HEAD)


git diff args
--------------

git diff <lhs-commit> <rhs-commit> <file-path>

git diff HEAD -- <all-files>



Difftool with a different tool
------------------------------

git difftool -t meld

stash
------

#create a stash
git stash

#create a stash with a custom message
git stash save "some custom message"

#re-apply a stash
git stash pop

#list all stashes
git stash list

#delete a stash
git stash drop
git stash drop stash@{1}

#show content w/o applying
git stash show -p
git stash show -p stash@{1}


***********

Vim-fugitive notes
=================

* fugitive works only on a file. So just open a file and then issue any fugitive command

:Gdiff             # diff the current file's changes from index
:Gdiff HEAD
:Gdiff any_treeish

:Gedit <commit>
:Glog -n 5         #log the current-file, until 5 commits
:Glog -n 5 --      #log from HEAD to HEAD~4

To get the current commit while watching Gedit - y, then ^g

Equivalents
-----------

cmd-line           fugitive            Comments
git anything       :Git anything       Execute any random git command

:Git add %         :Gwrite             Stage the current file to the index
:Git checkout %    :Gread              Revert current file to last checked in version
:Git rm %          :Gremove            Delete the current file and the corresponding Vim buffer
:Git mv %          :Gmove              Rename the current file and the corresponding Vim buffer

:Git commit        :Gcommit
:Git status        :Gst

***********

GIt-notes
--------
There are 3 object types

1. blob   - File-contents
2. tree   - dir-listing, that bundles blobs together
3. commit - that points to a tree, with a meta-data like comments, author and a pointer to the previous commit(s)!.

A branch is simply a pointer to a commit. HEAD is a pointer to the current branch!

Know type of a sha
------------------

git cat-file -t <sha>

Get new clone
-----------

git-ws --branch v160.main asr5k/master.git master

git submodule
git submodule status | grep '^ '

rolldown:

git forest pull

Creating a simple tag
----------------------

git tag <tagname> <commit>

creating a annotated tag
-----------------------

git tag -a <tagname> -m '<message>'

Get info of a annotaed tag
---------------------------

git tag -l 'prefix*'   # will give all tags that start with prefix
git tag -l '*substr*'  # will give all tags that have substr

git show <tag-name>    # will show info of tag + the commit as well. Can get the time of the tagging.

Push only one or a few commits when we have more local commits
--------------------------------------------------------------

git push <remotename> <commit SHA>:<remotebranchname>
git push <remotename> <commit SHA>:refs/heads/<new-remotebranchname-name>

Push a tag
-----------

git push origin <tag_name>

delete a tag from remote
------------------------

git push --delete origin tagname

#https://nathanhoad.net/how-to-delete-a-remote-git-tag
git push origin :refs/tag/tagname

delete commits from remote
---------------------------

#This will force remote to sync up with us.
#Assuming all refspecs are set i.e tracking branch is set
git push remote_name -f

# This will do it wherever u are w/o any tracking branch set.
git push remote_name +COMMIT_ID:branch


getting latest /top commit
-----------------------
git log -n 1
git log -n 1 --pretty=format:"%H"

geting parent commit of a commit
---------------------------------

git show --quiet --pretty=format:"%P" <commit>

commit~1  .. First Parent of commit
commit~2  .. Grand(second) Parent of commit

commit^1  .. First left parent of commit
commit^2  .. second left parent of commit (meaningful for merge commits)


which branches contain a commit
------------------------------

git branch -a --contains <commit>

which commit has a certain version of file
------------------------------------------

which_commit_has_this_blob.pl <blob-sha>

getting rid of a submodule
---------------------------

git submodule deinit packages/<..>


doing a csettool:
-----------------

commit=<whatever>
parent=$(git show --quiet --pretty=format:"%P" $commit)
git meld $parent $commit

Getting older revisions of files:
---------------------------------

Get the revision of a submodule of a particular revision of a super module

git ls-tree buildnumber_50269 packages/common
cd packages/common
git show <commit>:<file>

getting the commit id of a submodule for a given commit of super-module
------------------------------------------------------------------------

git ls-tree -r <master-commit> | grep 'packages/<package>'

git ls-tree -r HEAD | grep 'packages/<package>'

is a commit in a build-number
-----------------------------

git merge-base --is-ancestor <commit> buildnumber_<build>

During merging / merge
--------------

# list conflict files
git diff --name-only --diff-filter=U

# to keep local or remote files
git checkout --theirs /path/to/file
git checkout --ours /path/to/file

git ls-files -u
  1: common
  2: ours
  3: theirs

Better merge strategy
--------------------

git merge|rebase|cherry-pick  --strategy=recursive --strategy-option=patience

To amend dates for a bulk of commits
-------------------------------------

git rebase -i
#choose edit in the EDITOR
#and do this when you are prompted in each stage

git commit --amend --date="Wed Feb 16 14:00 2011 +0100"
git rebase --continue

#rebase w/o a tracking branch or if u have pushed
git rebase -i parent_of_commit_to_rebase master

Bisect
-------

git bisect start <bad> <good> --
git bisect run /script

git bisect start HEAD TiMOS-MG_0_0_I1630 --

worktree
---------

git worktree add <path> [<branch>]    # add path and checkout branch into it.

Eg:
----
$ git worktree add -b emergency-fix ../temp master
$ pushd ../temp
# ... hack hack hack ...
$ git commit -a -m ´emergency fix for boss´
$ popd
$ rm -rf ../temp
$ git worktree prune
----

git worktree list

goto root of repo
-----------------

#gives absolute path
git rev-parse --show-toplevel

#gives relative-path (or) empty if already in root
git rev-parse --show-cdup

#useful bash-alias for bashrc
alias gitroot='cd ./$(git rev-parse --show-cdup)'

panos-flow
~~~~~~~~~~

#to create study only branches off some tag
git worktree add -b 60R4_study   ../../60R4_study/panos TiMOS-MG_6_0_R4

#to create a regular working branch to push
git worktree add -b mg80f ../../mg80f/panos remotes/origin/TiMOS-MG_8_0_future


Avoid typing passwords
----------------------

#WARNING: very very weak. All passwords in clear text 

#locally update your repo's config.
git config credentials.helper store

#your password will bein ~/.git-credentials in clear text.






Old commands equivalent
-----------------------

bk -r diffs -u -p            git diff -u -p
bk sfiles -Ug                git ls-tree -r HEAD --name-only
bk sfiles -cg                git ls-files --modified
bk sfiles -gp                git ls-files --cached
bk unedit <file>             git checkout -- <file>                       .. careful!
bk unedit $(bk sfiles -cg)   git checkout -- $(git ls-files --modified)   .. careful!
bk delta -Y $(..)            git add $(git ls-files --modified)
bk sfiles -x                 ??
bk changes                   git log
bk changes -L                git log  origin/v160.main..HEAD
bk changes -R                git fetch ; git log ..origin/v160.main
                             git fetch ; git log ..$(git branch -vv | grep '^*' | awk -F\' '{print $2}')
bk cset -r                   git diff-tree --no-commit-id --name-only -r <commit-id>
model                        git submodule status | grep -v '^-'
                             git submodule status | grep -v '^-' | awk ' {print $2 }' | awk -F\/ '{print $2}'| grep -v buildtools
bk undo -r<>                 git reset --hard HEAD~1
bk cset -x                   ??
bk export -tpatch            git show --pretty=format: <commit> | tail -n +2
bk changes -u<user>          git log --author=<user>
bk changes -/text/           git log --grep=<text>


***********

Create a new branch

git checkout -b branch_name

Switch to a branch

git checkout test

Create a new branch that tracks a branch

git branch -t name remotes/origin/name
git checkout name


*****

Info model
-----------

files,
a working tree,
an index,
a local repository,
a remote repository,
remotes (pointers to remote repositories),
commits,
treeishes (pointers to commits),
branches,
a stash

refs
tags
the reflog
fast-forward commits
detached head state
remote branches
tracking
namespaces



*******

cvs commands

#set a CVSROOT
cvs -d '<...>' co repoName

#get root
cat CVS/Root

#update a repo
cvs update -Pqd

*******

svn commands
=============

Reference: http://svnbook.red-bean.com/en/1.7/index.html

Concepts
----------

Revisions
~~~~~~~~~

HEAD     -> the top one in the repo
BASE     -> the one in my working-dir, before my changes
COMMITED -> the actual revision starting from BASE(inclusive) in which the file changed.
PREV     -> COMMITED-1.

branches are represented as sub-folders in repos/your_repo_name/branches/branch_name
master is under                            repos/your_repo_name/trunk/

svn-status symbols

M modified
X untracked
~ file-type has changed (very likely a file became a link etc..)

Commands
---------
#see what's changed - just filenames
svn status

#see what's locally changed - patches
svn diff

#log a file
svn log filename

#get a particular version of file
svn cat -r 3 http://svn.red-bean.com/repos/test/readme.txt

#reset to a particular revision
svn update -r <earlier_revision_number>

#revert any modifications (or merge) - WARN changes are LOST
svn revert -R .

#dump file names of a commit
svn log --verbose -r <commit>
svn diff --summarize -r<rev>:<rev-1>

#dump actual contents of a commit with diffs
svn diff -r<rev-1>:<rev>

#check what files have changed in remote w/o updating
svn status -u

#commit
svn commit -m "ASN-XXXX: commit message"

#merge
cd target_repository
svn merge -c <commit-no> /path/to/src/branch/repository

#conflict
* pospostone during update
* conflict files are marked with C.
* Work on it.
* svn resolve --accept=working


***********

git-svn
--------

export CPPFLAGS="-I$HOME/local/include -I$HOME/local/lib/libffi-3.0.13rc1/include -I$HOME/install/ra_serf/include/serf-1"
export LD_FLAGS="-L$HOME/local/include -L$HOME/local/include/ncurses -L$HOME/local/lib -L$HOME/local/lib64 -L$HOME/install/ra_serf/lib"
export LDFLAGS="-L$HOME/local/include -L$HOME/local/include/ncurses -L$HOME/local/lib -L$HOME/local/lib64 -L$HOME/install/ra_serf/lib"
export LD_LIBRARY_PATH="$HOME/local/lib64:$HOME/local/lib:$HOME/install/ra_serf/lib"

git svn clone --stdlayout --authors-file=./authors.txt "http://depot/repo/asn" git_asn
git checkout -b R_1_8_0-svn origin/R_1_8_0
git checkout -b R_1_6_5-svn origin/R_1_6_5

git checkout R_1_8_0-svn && git svn rebase
git checkout R_1_6_5-svn && git svn rebase

#on a new branch
branch=R_1_8_2
git_wt_dir_name=182_first_git

#these are standard - no need to edit.
git_root=/home/lakshman_narayanan/ws/git-dir-for-svn
git_work_tree_dir=/home/lakshman_narayanan/ws/git-clones
wt_asn=${git_work_tree_dir}/git_asn_worktree_main
wt_import=${git_work_tree_dir}/git_import_worktree_main

svn_added_name=${branch}-svn
cd ${git_root}/git_asn
git checkout -b ${svn_added_name} origin/${branch}
cd ${git_root}/git_import
git checkout -b ${svn_added_name} origin/${branch}

cd ${wt_asn}
git fetch
git worktree add -b $svn_added_name ../${git_wt_dir_name}/${branch} remotes/origin/${svn_added_name}

cd ${wt_import}
git fetch
git worktree add -b $svn_added_name ../${git_wt_dir_name}/${branch}/import remotes/origin/${svn_added_name}

cd ${git_work_tree_dir}/${git_wt_dir_name}
echo ${branch} > .branch_name
echo "${branch} worktree" > .comments

#update aryaka-new-clone/shiftclone.py of the dir-names both normal and git.
#update aryaka-new-clone/update_git_root_clones.sh of the new branch

