
List all tracked files
----------------------

git ls-files
git ls-tree --full-tree -r HEAD   # too complex for the above?

List all untracked files
------------------------

git ls-files --others --exclude-standard

Get a particular revision
-------------------------

git show treeish:path/to/file

use HEAD to get the tip.

Git bring back a file discarding chagnes
---------------------------------------

git checkout -- path/to/file

restore to head discarding all changes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

git checkout -- .

getting rid of the top-commit
-----------------------------

git reset --hard HEAD~1

# you can get it back as long as its in the same repo with git reflog (git pack may erase it after some time..)

List all branches in server and clone
----------------------------

git branch -a

checkout remote branch with tracking
-------------------------------------

git checkout --track -b <local branch> <remote>/<tracked branch>

# if -b <name> is to be same as remote's name, you can skip it
git checkout -t origin/haml

TO see all changes to a file across all branch
----------------------------------------------

git log --all -- <path/to/file>

Various flavors of git-log
--------------------------

git log --author=abc         # show all commits of author
git log --grep=efg           # show all commits with comments having the string
git log -S=hij               # show all commits with changed lines having the string. Slower -> so narrow ur commit-list
git log --name-only          # display names of files changed with every commit

git log --pretty=fuller      # shows both dates

To quickly get the sha-1 of any tag/branch-name/commit-representative!
----------------------------------------------------------------------

#especially if you are in a script
git rev-parse HEAD
git rev-parse tag_name

#to check if this is a git-repo
git rev-parse HEAD
if [ $? -eq 0 ] ; then
  echo "you are in a git repo"
else
  echo "you are NOT in a git repo"

***********

Vim-fugitive notes
=================

* fugitive works only on a file. So just open a file and then issue any fugitive command

:Gdiff             # diff the current file's changes from index
:Gdiff HEAD
:Gdiff any_treeish

:Gedit <commit>
:Glog -n 5         #log the current-file, until 5 commits
:Glog -n 5 --      #log from HEAD to HEAD~4

Equivalents
-----------

cmd-line           fugitive            Comments
git anything       :Git anything       Execute any random git command

:Git add %         :Gwrite             Stage the current file to the index
:Git checkout %    :Gread              Revert current file to last checked in version
:Git rm %          :Gremove            Delete the current file and the corresponding Vim buffer
:Git mv %          :Gmove              Rename the current file and the corresponding Vim buffer

:Git commit        :Gcommit
:Git status        :Gst

***********

GIt-notes
--------
There are 3 object types

1. blob   - File-contents
2. tree   - dir-listing, that bundles blobs together
3. commit - that points to a tree, with a meta-data like comments, author and a pointer to the previous commit(s)!.

A branch is simply a pointer to a commit. HEAD is a pointer to the current branch!


Get new clone
-----------

git-ws --branch v160.main asr5k/master.git master

git submodule  
git submodule status | grep '^ '

rolldown:

git forest pull

Getting a tag
--------------

git-ws --tag  buildnumber_54290 asr5k/master master

creating a annotated tag
-----------------------

git tag -a <tagname> -m '<message>'

Get info of a annotaed tag
---------------------------

git tag -l 'prefix*'   # will give all tags that start with prefix
git tag -l '*substr*'  # will give all tags that have substr

git show <tag-name>    # will show info of tag + the commit as well. Can get the time of the tagging.

Push only one or a few commits when we have more local commits
--------------------------------------------------------------

git push <remotename> <commit SHA>:<remotebranchname>
git push <remotename> <commit SHA>:refs/heads/<new-remotebranchname-name>

Push a tag
-----------

git push origin <tag_name>

delete a tag from remote
------------------------

git push --delete origin tagname

#https://nathanhoad.net/how-to-delete-a-remote-git-tag
git push origin :refs/tag/tagname


getting latest /top commit
-----------------------
git log -n 1
git log -n 1 --pretty=format:"%H"

geting parent commit of a commit
---------------------------------

git show --quiet --pretty=format:"%P" <commit>

which branches contain a commit
------------------------------

git branch -a --contains <commit>

getting rid of a submodule
---------------------------

git submodule deinit packages/<..>


doing a csettool:
-----------------

commit=<whatever>
parent=$(git show --quiet --pretty=format:"%P" $commit)
git meld $parent $commit

Getting older revisions of files:
---------------------------------

Get the revision of a submodule of a particular revision of a super module

git ls-tree buildnumber_50269 packages/common
cd packages/common
git show <commit>:<file>

getting the commit id of a submodule for a given commit of super-module
------------------------------------------------------------------------

git ls-tree -r <master-commit> | grep 'packages/<package>'

git ls-tree -r HEAD | grep 'packages/<package>'

is a commit in a build-number
-----------------------------

git merge-base --is-ancestor <commit> buildnumber_<build>

During merging
--------------

# list conflict files
git diff --name-only --diff-filter=U

# to keep local or remote files
git checkout --theirs /path/to/file
git checkout --ours /path/to/file

To amend dates for a bulk of commits
-------------------------------------

git rebase -i
#choose edit in the EDITOR
#and do this when you are prompted in each stage

git commit --amend --date="Wed Feb 16 14:00 2011 +0100"
git rebase --continue


Old commands equivalent
-----------------------

bk -r diffs -u -p            git diff -u -p
bk sfiles -Ug                git ls-tree -r HEAD --name-only 
bk sfiles -cg                git ls-files --modified
bk sfiles -gp                git ls-files --cached
bk unedit <file>             git checkout -- <file>                       .. careful!
bk unedit $(bk sfiles -cg)   git checkout -- $(git ls-files --modified)   .. careful!
bk delta -Y $(..)            git add $(git ls-files --modified)
bk sfiles -x                 ??
bk changes                   git log 
bk changes -L                git log  origin/v160.main..HEAD
bk changes -R                git fetch ; git log ..origin/v160.main
                             git fetch ; git log ..$(git branch -vv | grep '^*' | awk -F\' '{print $2}')
bk cset -r                   git diff-tree --no-commit-id --name-only -r <commit-id>
model                        git submodule status | grep -v '^-'
                             git submodule status | grep -v '^-' | awk ' {print $2 }' | awk -F\/ '{print $2}'| grep -v buildtools
bk undo -r<>                 git reset --hard HEAD~1
bk cset -x                   ??
bk export -tpatch            git show --pretty=format: <commit> | tail -n +2 
bk changes -u<user>          git log --author=<user>
bk changes -/text/           git log --grep=<text>


***********

Create a new branch

git checkout -b branch_name

Switch to a branch

git checkout test

Create a new branch that tracks a branch

git branch -t name remotes/origin/name
git checkout name


