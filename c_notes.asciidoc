C Notes
=======
:toc:

== Declarations

* What is really guaranteed on sizes? http://c-faq.com/decl/inttypes.html[Faq 1.1]
** type char can hold values up to 127(1 byte);
** types short int and int can hold values up to 32,767(2 bytes); and
** type long int can hold values up to 2,147,483,647(4 bytes).
** something like the relation
+
----
    sizeof(char) <= sizeof(short) <= sizeof(int) <= sizeof(long) <= sizeof(long long)
----
* Use size_t when dealing with sizes.
* Use int, double when possible - fastest data-types.
** Using things like char, short, float may result in more code.
* typedefs have scope rules. So they should be preferred over #defines.

=== String Initialization
A string literal (the formal term for a double-quoted string in C source) can
be used in two slightly different ways:

----
char a[] = "string literal";
char *p  = "string literal";
----

* As the initializer for an array of char, as in the declaration of char a[] ,
  it specifies the initial values of the characters in that array (and, if
  necessary, its size).
* Anywhere else, it turns into an unnamed, static array of characters, and this
  unnamed array may be stored in read-only memory, and which therefore cannot
  necessarily be modified. In an expression context, the array is converted at
  once to a pointer, as usual (see section 6), so the second declaration
  initializes p to point to the unnamed array's first element.


=== Some complex typedef styles

* Typedefing function pointers
+
----
typedef int (*funcptr)();
----
+
Now both the following are same.
+
----
funcptr pf1, pf2;
int (*pf1)(), (*pf2)();
----
* Typedefing pointers
+
----
typedef char *charp;
const charp p;
----
+
Will make p a +char $$*$$const p+ and not +const char $$*$$p+. This is desirable.

=== Namespaces

* Detailed in this http://c-faq.com/decl/namespace.html[Faq 1.29]

There are 4 major namespaces

* labels (i.e. goto targets);
* tags (names of structures, unions, and enumerations; these three aren't separate even though they theoretically could be);
* structure/union members (one namespace per structure or union); and
* everything else (functions, variables, typedef names, enumeration constants), termed ``ordinary identifiers'' by the Standard.
** Note that the struct-names comes under 2nd category, while typedef-names sit along-side variable names

== Some facts to remember

* size_t is unsigned.
* struct compare isn't directly possible, as there are unused/padding holes in the struct.
* ANSI C has a offsetof(type,field) macro in <stddef.h>
* bit-fields are possible only within a struct/union definition

== Sequence points

* The following in undefined (not even unspecified)
+
----
a[i] = i++;
i = i++;
a ^= b ^= a ^= b
----
+
* Operator precedance doesn't gurantee function evaulation sequence
+
----
f() + g() * h()  /* although * happens before +, f,g,h can be called in any order */
----
+
* Comma opeartor guarantees left to right evaulation (each comma is a sequence point). But function arguments
  are not comma operators and doesn't guranatee order of evaluation
+
----
printf("%d %d", f1(), f2());   /* no guarantee on order of f1 or f2 */
----


== Signatures of common routines

* main
+
----
int main(int argc, char **argv)
----
+
* strcpy
+
----
char *strcpy(char *dest, const char *src);
char *strncpy(char *dest, const char *src, size_t n);
----
+
** strcpy/memcpy return the char*/void* of dst.
* strtol, atoi
+
----
long int strtol(const char *nptr, char **end_ptr, int base);
long long int strtoll(...);
----
+
** long atol(const char*) (or atoi) is same as strtol(ptr, NULL, 10);
** base is any of 0 to 36 (inclusive). 0 means 0x-begin, 0-begin or 10-base.
** end_ptr if non-NULL is set to the location of ptr which has first non-0 bad value. if it points to '\0', the entire string was good.
** errno is ERANGE if return is LONG_MAX/MIN and long doesn't fit.

== Compilation Tips

* Argument -E in gcc stops at preprocessing stage
* Argument -dM in processing stage dumps all macro definitions used.

////
Last read FAQ: 3.7
////
